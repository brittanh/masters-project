#  _________________________________________________________________________
#
#  Pyomo: Python Optimization Modeling Objects
#  Copyright (c) 2014 Sandia Corporation.
#  Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
#  the U.S. Government retains certain rights in this software.
#  This software is distributed under the BSD License.
#  _________________________________________________________________________


"""
This is the class to design and test iNMPC controllers
"""

from __future__ import division

__all__ = ['AdvancedStepNMPC']

# Imports for iNMPC
from pyomo.core.base import *
from pyomo.core.base.var import SimpleVar
from pyomo.dae import *
from pyomo.dae.plugins.colloc import Collocation_Discretization_Transformation
from pyomo.dae.plugins.finitedifference import Finite_Difference_Transformation
from pyomo.opt import SolverFactory
from pyomo.opt import SolverStatus, TerminationCondition
from decimal import Decimal

# Imports for nl writing
from pyomo.opt import ProblemFormat
from pyomo.core.base import SymbolMap
import re
import time
from subprocess import call
from pyomo.opt.plugins.sol import ResultsReader_sol

# Imports for gjh
from scipy.sparse import csr_matrix
from scipy.sparse import lil_matrix
from scipy.sparse.linalg import spsolve
import numpy as np

## =============================================================================
## NEW IMPORTS FOR (N)MPC
## =============================================================================
from Disturbance import *
from InitialCondition import *
from ManipulatedVar import *

# New import from plotting
from DynamicPlot import *
        
    
def find_comp(name, pyomo_model):
    """ 
    A function that returns a component of a pyomo model given its name as a
    string including the corresponding indexes
    """
    name_tmp = re.search("(.*)\[(.*)\]",name)   
    if name_tmp == None:
        component = pyomo_model.find_component(name)
        pyomo_object = component
        ix = ''
    else:
        component = pyomo_model.find_component(name_tmp.groups()[0] + '[**]')
        ix = name_tmp.groups()[1]
	for index in component:          	    
	    ind = ''
	    try: 
	        for i in range(len(index)):
		    if i == len(index) - 1:
			ind += str(index[i])
		    else:		   	    	   	    
			ind += str(index[i]) + ','	    	    	    	        	    	    	    
	    except TypeError:
		ind = str(index)
	    if ind == ix:    	    	    
		pyomo_object = component[index]   			    
    return pyomo_object    

class nl_map_asNMPC():
    """
    The definition of a class that creates and modify the nl file of an 
    optimization problem
    """
    
    def __init__ (self, pyomo_model, file_name='untitled'):
        """
	It initialize the objects of this class creating the .nl, .col, .row 
	files associated with the pyomo model. 
	It also creates the symbolic map and dictionaries that relates pyomo's 
	object with nl names
	It creates a dictionary between the artificial constraints and the 
	corresponding variable
	"""
	# Important atributes
	self.name = file_name	
	self.nl_change = False
	self.x_numvar = None
	self.d_numvar = None
	self.cons_num = None
	self.x_line = None
	self.d_line = None
	self.calls2update_Parameters = 0	
	self.r_line = None	
	self.call2update_InitialGuess = 0
	self.var_dict = {}
	self.num_var_lo = 0
	self.num_var_up = 0
	self.dual_dict = {}
	# Write .nl .col .row files			
	t00 = time.time()
	pyomo_model.write(file_name +'.nl', format = ProblemFormat.nl,
		io_options = {'symbolic_solver_labels':True, 
			      'file_determinism':3})
	self.nl_writting_time = time.time() - t00
	#Creating mapping and dictionaries	
	t00 = time.time()
	with open(file_name +'.col') as f:
	    varnames = [line.strip() for line in f.readlines()]
	with open(file_name +'.row') as f:
	    connames = [line.strip() for line in f.readlines()]
	objname = connames.pop()				
	#Create symbol map identical to that generated by the nl file interface
	self.symbol_map = SymbolMap()				
	symbol_list = []	
	self.pyomo2nl = {} 
	self.nl2pyomo = {} 
	self.pyomoName2pyomoObject = {}
	for cntr, name in enumerate(varnames):
	    symbol = 'v' + str(cntr)
	    component = find_comp(name, pyomo_model)
	    symbol_list.append((component, symbol))   
	    self.pyomo2nl[name] = 'V' + str(cntr) 	
	    self.nl2pyomo['V' + str(cntr)] = name
	    self.pyomoName2pyomoObject[name] = component
	for cntr, name in enumerate(connames):
	    symbol = 'c' + str(cntr)
	    component = find_comp(name, pyomo_model)
	    symbol_list.append((component, symbol))   
	    self.pyomo2nl[name] = 'C' + str(cntr)
	    self.nl2pyomo['C' + str(cntr)] = name
	    self.pyomoName2pyomoObject[name] = component
	symbol = 'o'+str(0)
	component = pyomo_model.find_component(objname)
	symbol_list.append((component, symbol))		
	self.symbol_map.addSymbols(symbol_list) 
	# Create additional dictionaries
	self.update_InitialGuess(pyomo_model, var_class=True)
	self.var_classification()
	#Dictionary for artificial constraint and variable	
	self.artificial_classification()
	self.nl_dictWritting_time = time.time() - t00
	
    def artificial_classification(self):
    	"""
    	It creates a dictionary between the artificial variables and its
    	corresponding artificial constraint
    	"""
    	self.var2artcons = {}
	self.artcons2var = {}
	id2var = {}
	nl_file = open(self.name + '.nl','r')
	nl_lines = nl_file.readlines()
	nl_file.close()
	var_indicator = re.search("(S4 )(\d\d*)( sens_state_0)", 
					''.join(nl_lines))  
	var_num = int(var_indicator.groups()[1])                                        
	var_line = nl_lines.index(''.join(var_indicator.groups()) + '\n')			
	cons_indicator = re.search("(S5 )(\d\d*)( sens_init_constr)", 
					''.join(nl_lines))			
	cons_num = int(cons_indicator.groups()[1])
	cons_line = nl_lines.index(''.join(cons_indicator.groups()) + '\n')			
	if var_num == cons_num:
	    for line_number in range(var_line + 1, var_line + var_num + 1, 1):
	        line = nl_lines[line_number].strip().split()					
		var_name = self.nl2pyomo['V' + str(line[0])]
		id_var = line[1]					
		id2var[id_var] = var_name
	    for line_number in range(cons_line + 1, cons_line + cons_num + 1,1):
		line = nl_lines[line_number].strip().split()					
		cons_name = self.nl2pyomo['C' + str(line[0])]
		var_name = id2var[line[1]]
		self.var2artcons[var_name] = cons_name
		self.artcons2var[cons_name] = var_name				
		nl_lines[line_number] = line[0] + ' ' + '1' + '\n'										
	else:
	    raise ValueError("Error in the suffixes " +\
				"denfition within the model")	
	# Overwrite nl file
	nl_file = open(self.name + '.nl', 'w')
	nl_file.seek(0,0)		
	nl_file.writelines(nl_lines)			
	nl_file.close()		 
            			
    def var_classification(self):
    	"""
    	It creates a dictionary between the variable code (V###) and a list
    	corresponding to its current value, its lower bound and its upper bound
    	"""
    	#Variables with lower and upper bounds    	    	
        nl_file = open(self.name + '.nl','r')
	nl_lines = nl_file.readlines()
	nl_file.close()
	#self.x_numvar = re.search("(x)(\d\d*)", ''.join(nl_lines))
	#self.x_line = nl_lines.index('x' + self.x_numvar.groups()[1] + "\n")
	self.b_line = nl_lines.index("b\n")		
        for i in range(int(self.x_numvar.groups()[1])):
            var_number = i
            var_value = float(nl_lines[self.x_line + i + 1].split()[1])
            var_bounds = nl_lines[self.b_line + i + 1].split()
            if var_bounds[0] == '0':
                self.var_dict['V' + str(i)] = [var_value, 
                		float(var_bounds[1]), float(var_bounds[2])]
                self.num_var_lo += 1
                self.num_var_up += 1		
            elif var_bounds[0] == '1':
                self.var_dict['V' + str(i)] = [var_value, 
                		None, float(var_bounds[1])]                
                self.num_var_up += 1
            elif var_bounds[0] == '2':
            	self.var_dict['V' + str(i)] = [var_value, 
            			float(var_bounds[1]), None]
            	self.num_var_lo += 1                
            elif var_bounds[0] == '3':
            	self.var_dict['V' + str(i)] = [var_value, 
            			None, None]     
	       
    def update_InitialGuess(self, pyomo_model_with_results, var_class=False, update_duals=False):
        """
        Update the initial values (guess) of all the primal variables 
        in the nl file
        It uses the values set in the correcponding pyomo model
        It can also initialize the dual variables
        """
	pmwr = pyomo_model_with_results		
	# Read nl file as lines
	nl_file = open(self.name + '.nl', 'r')		
	nl_lines = nl_file.readlines()	
	nl_file.close()
	if self.call2update_InitialGuess == 0 or self.nl_change:
	# Identify number of variables (x primal, d dual)
    	    self.x_numvar = re.search("(x)(\d\d*)", ''.join(nl_lines))					
    	    self.d_numvar = re.search("(d)(\d\d*)", ''.join(nl_lines))
    	    self.cons_num = int(nl_lines[1].strip().split()[1])
    	    self.var_num = int(nl_lines[1].strip().split()[0])			
    	    # Identify index of x in list	
    	    self.x_line = nl_lines.index('x' + self.x_numvar.groups()[1] + "\n")
    	    self.nl_change = False
        # Read and modify lines after xnn
        if int(self.x_numvar.groups()[1]) < self.var_num or var_class:
            self.r_line = nl_lines.index("r\n")	
	    nl_lines_1 = nl_lines[:self.x_line+1]
	    nl_lines_2 = nl_lines[self.r_line:]
	    nl_lines_1.pop(-1)	    
	    nl_lines_1.append('x' + str(self.var_num) + "\n")
	    for variable_number in range(0, self.var_num, 1):
	        pyomo_var_name = self.nl2pyomo['V' + str(variable_number)]			
	        pyomo_var_value = 0
	        nl_lines_1.append(str(variable_number) + ' ' +
	        			str(pyomo_var_value) + "\n")
	    del nl_lines
	    nl_lines = nl_lines_1 + nl_lines_2	
	    self.x_numvar = re.search("(x)(\d\d*)", ''.join(nl_lines))
	    self.x_line = nl_lines.index('x' + self.x_numvar.groups()[1] + "\n")
	    self.nl_change = True
    	else:			
	    for line_number in range(self.x_line + 1, 
	    	    	self.x_line + int(self.x_numvar.groups()[1]) + 1, 1):			
	        line = nl_lines[line_number].strip().split()			
	        pyomo_var_name = self.nl2pyomo['V' + line[0]]			
	        pyomo_var_value = self.pyomoName2pyomoObject[pyomo_var_name].value
		if pyomo_var_value is None:
		    pyomo_var_value = 0	
	        value_bounds = self.var_dict['V' + line[0]]
	        self.var_dict['V' + line[0]] = [pyomo_var_value, 
	        				value_bounds[1], value_bounds[2]] 
	        nl_lines[line_number] = line[0] + ' ' + str(pyomo_var_value) + "\n"			
	# Check the update duals option
	if update_duals:
	    # Check if d is in the nl file			
	    if self.d_numvar == None:			
	        nl_lines_1 = nl_lines[:self.x_line]
		nl_lines_2 = nl_lines[self.x_line:]
		nl_lines_1.append('d' + str(self.cons_num) + "\n")
		for constraint_number in range(0, self.cons_num, 1):
		    pyomo_cons_name = self.nl2pyomo['C' + str(constraint_number)]			
		    pyomo_dual_value = pmwr.dual[self.pyomoName2pyomoObject[pyomo_cons_name]]
		    self.dual_dict['C' + str(constraint_number)] = pyomo_dual_value
		    nl_lines_1.append(str(constraint_number) + ' ' +
		    	    			str(pyomo_dual_value) + "\n")
		    
		del nl_lines
		nl_lines = nl_lines_1 + nl_lines_2	
		self.d_numvar = re.search("(d)(\d\d*)", ''.join(nl_lines))
		self.d_line = nl_lines.index('d' + self.d_numvar.groups()[1] + "\n")
		self.nl_change = True
	    # If d is already in the nl file
	    else:		
		if self.call2update_InitialGuess == 0: 
		    self.d_line = nl_lines.index('d' + self.d_numvar.groups()[1] + "\n")
	        # Read and modify lines after dnn
	        for line_number in range(self.d_line+1, 
	        	self.d_line + int(self.d_numvar.groups()[1]) + 1, 1):
		    line = nl_lines[line_number].strip().split()
		    pyomo_cons_name = self.nl2pyomo['C' + line[0]]					
		    pyomo_dual_value = pmwr.dual[self.pyomoName2pyomoObject[pyomo_cons_name]]
		    self.dual_dict['C' + line[0]] = pyomo_dual_value
		    nl_lines[line_number] = line[0] + ' ' + str(pyomo_dual_value) + "\n"
	        self.nl_change = False
        # Overwrite nl file
	nl_file = open(self.name + '.nl', 'w')
	nl_file.seek(0,0)		
	nl_file.writelines(nl_lines)			
	nl_file.close()	
	self.call2update_InitialGuess += 1	
	
    def update_Parameters(self, dict_NewValues):
        """
	It updates the parameters of the model that are defined as artificial 
	constraints (e.g. initial conditions and disturbances)
	"""					
	# Read nl file
	nl_file = open(self.name+'.nl','r')
	nl_lines = nl_file.readlines()
	nl_file.close()	 
	# Modify values
	if self.calls2update_Parameters == 0 or self.nl_change:
	    self.InitialParam2line = {} # Dictionary to save lines modified
	    self.r_line = nl_lines.index("r\n")
	    if self.cons_num is None:
	        self.cons_num = nl_lines[1].strip().split()[1]
	    for line_number in range(self.r_line+1,self.r_line+1+int(self.cons_num)):
	        C_ID = line_number - (self.r_line+1)
		cons_name = self.nl2pyomo['C'+str(C_ID)]
		if cons_name in self.artcons2var:
		    var_name = self.artcons2var[cons_name]			    
		    nl_lines[line_number] = '4 ' + str(dict_NewValues[var_name][2]) + "\n"					
		    self.InitialParam2line[var_name] = line_number
	else:
	    for var_name in self.InitialParam2line.keys():
	        line_number = self.InitialParam2line[var_name]				
		nl_lines[line_number] = '4 ' + str(dict_NewValues[var_name][-1]) + "\n"
	# Overwrite nl file
	nl_file = open(self.name+'.nl', 'w')
	nl_file.seek(0,0)		
	nl_file.writelines(nl_lines)			
	nl_file.close()	
	self.calls2update_Parameters += 1
	
class AdvancedStepNMPC():
    """
    The definition of an iNMPC class. 
    ideal Nonlinear Model Predictive Control    
    
    Public attributes:
    *disturbances: set of all the disturbances
    *manipulated_var: set of all the manipulated variables
    *state_var: set of all the state variables
    *initial_conditions: set of all the intial conditions
    	
    The default configuration is to discretize everything using the 
    LAGRANGE-RADAU representation with three collocation points and 
    prediction_horizon finite elements. It also considers the distrubances to 
    be constant in the unless it is specified the oposite later.
    """
    def __init__(self, model=None, model_time=None, prediction_horizon=0, 
    	    control_horizon=0, simulation_periods=0, 
    	    default_discretization=True):    		
	if model == None:
		raise TypeError("A pyomo model must be specified")
#	if type(model) is not ConcreteModel:
#		raise TypeError("The component specified using the 'model'" + \
#			" keyword must be a concrete Pyomo model")		
	#Model for pptimal control problem
	self.OCP = model
	#Model for prediction
	self.PM = model.clone()	
	
	if model_time is None:
            raise TypeError("A differential set must be specified for the time")
        if model_time.type() is not ContinuousSet:
            raise TypeError("The component specified using the 'model_time'" + \
            	    " keyword must be a differential set")
        dt = model.find_component(model_time.cname(True))
        
        if dt is None:
            raise ValueError("DifferentialSet '%s' is not a valid component" + \
            	    " of the discretized model instance" %(diffset.cname(True)))
        # OCP time
	self._OCP_time = dt
	# PM time
        self._PM_time = self.PM.find_component(model_time.cname(True))
        
        if type(prediction_horizon) is not int or int(prediction_horizon) <= 0:
            raise TypeError("The prediction horizon must be a positive" + \
            	    " integer greater than zero")
        self._prediction_horizon = prediction_horizon
        
        if type(control_horizon) is not int or int(control_horizon) <= 0:
            raise TypeError("The control horizon must be a positive integer" + \
            	    " greater than zero")
        if control_horizon > prediction_horizon:
            raise ValueError("The prediction horizon must be greater or" + \
            	    " equal to the control horizon")
        self._control_horizon = control_horizon
    	
    	if type(simulation_periods) is not int or int(simulation_periods) <= 0:
            raise TypeError("The number of simulation periods must be a" + \
            	    " positive integer greater than zero")
        self._simulation_periods = simulation_periods    	    
    	    	
    	self._sampling_time = max(self._OCP_time)#/self._prediction_horizon    	        
	self._OCP_time.add(self._sampling_time*self._prediction_horizon)
	self._OCP_time.discard(self._sampling_time)    		
    	
    	self.points_in_fe = 0
    	self._discretize_method = ''
    	
    	self._real_time = []
    	
    	self.manipulated_var, self.initial_conditions, self.disturbances, self.state_var = self.data_type_classification(self.OCP)    	
    	self.manipulated_var_PM, self.initial_conditions_PM, self.disturbances_PM, self.state_var_PM = self.data_type_classification(self.PM)    	   	
	
    	if default_discretization:    	    	    	
            self.discretize_model(discretization_type='OrthogonalCollocation',
            	    wrt=self._OCP_time, ncp=3, scheme='LAGRANGE-RADAU')                
 		
    def discretize_model(self, **kwds):
    	"""
    	This function applies the discretization scheme over the dynamic model
    	defined previously.
    	
    	Keyword Arguments:
    	discretization_type The desiered type of discretization to apply
    		      	    FiniteDifferences or OrthogonalCollocation
        ncp           The desired number of collocation points over each 
                      finite element.
        wrt           Indicates which ContinuousSet the transformation 
                      should be applied to. If this keyword argument is not
                      specified then the same scheme will be applied to all
                      ContinuousSets.
        scheme        Indicates which finite difference method to apply. 
                      Options are LAGRANGE-RADAU, LAGRANGE-LEGENDRE, or 
                      HERMITE-CUBIC for OrthogonalCollocation. BACKWARD, CENTRAL
                      or FORWARD for FiniteDifferences.
    	"""    	
    	tmpdisc_type = kwds.pop('discretization_type','OrthogonalCollocation')
	#tmpnfe = kwds.pop('nfe',10)
	tmpnfe = self._prediction_horizon
        tmpncp = kwds.pop('ncp',3)        
        tmpds = kwds.pop('wrt',None)        
        if (tmpdisc_type == 'OrthogonalCollocation'):
            tmpscheme = kwds.pop('scheme','LAGRANGE-RADAU')
            _scheme_name = tmpscheme.upper()
            self._discretize_method = Collocation_Discretization_Transformation()
            self._discretize_method.apply(self.OCP, wrt=tmpds, 
            	    nfe=tmpnfe, ncp=tmpncp, scheme=tmpscheme, inplace=True)
            self._discretize_method.apply(self.PM, wrt=self._PM_time, 
            	    nfe=1, ncp=tmpncp, scheme=tmpscheme, inplace=True)
            self.points_in_fe = tmpncp
        if (tmpdisc_type == 'FiniteDifferences'):
            tmpscheme = kwds.pop('scheme','BACKWARD')
            _scheme_name = tmpscheme.upper()
            self._discretize_method = Finite_Difference_Transformation()
            self._discretize_method.apply(self.OCP, wrt=tmpds, 
            	    nfe=tmpnfe, scheme=tmpscheme, inplace=True)
            self._discretize_method.apply(self.PM, wrt=self._PM_time, 
            	    nfe=1, scheme=tmpscheme, inplace=True)		
            self.points_in_fe = 1    	
    	self.set_RealTime()    	 
    	# Modify objective based on the new continuous set
	for obj in self.OCP.component_objects(Objective, active=True):	    
	    obj_rule = obj.rule
	    obj_sense = obj.sense
	    obj_expr = obj.expr
	    obj._active = False
	self.OCP.NEW_OBJ = Objective(rule=obj_rule, expr=obj_expr, 
					sense=obj_sense)  
	# Dictionary for updating the parameters
	self.dictUpdateParameters = self.gen_dictUpdateParameters(self.OCP, 
		self._OCP_time, self.disturbances, self.initial_conditions, 
		self.manipulated_var, prediction_model=False)	
	self.dictUpdateParameters_PM = self.gen_dictUpdateParameters(self.PM, 
		self._PM_time, self.disturbances_PM, self.initial_conditions_PM, 
		self.manipulated_var_PM, prediction_model=True)			

    def data_type_classification(self, model):
    	"""
    	This function classify all the data types in the pyomo model in 
    	dictionaries that relate the name of the object with the object itself    	
    	"""
    	manipulated_var = {}
    	initial_conditions = {}
    	disturbances = {}
    	state_var = {}
    	for obj in model.component_objects(Var, active=True):
    	    if (type(obj) is ManipulatedVar):
    	        manipulated_var[cname(obj)] = obj
    	    elif (type(obj) is SimpleInitialCondition or type(obj) is IndexedInitialCondition):
    	        initial_conditions[cname(obj)] = obj  
    	    elif (type(obj) is Disturbance):
    	        disturbances[cname(obj)] = obj
    	    elif isinstance(obj, Var):
    	        state_var[cname(obj)] = obj
    	return manipulated_var, initial_conditions, disturbances, state_var        	           	        
    	        
    def gen_dictUpdateParameters(self, model, time_set, 
    	    				dist_dict, IC_dict, manVar_dict, 
					prediction_model=False):
        """
        A function that generates the corresponding dictionaries between the 
        artificial variables and their new value
        It is called after the model discretization
        Keys: name with indexes as a string
        Values: list with the obejct, the index, and its current value
        """        
        dictUpdateParameters = {}        
        # Disturbances
        for dis in dist_dict.itervalues():
            for t in time_set:
                name = dis.name + '[' + str(t) + ']'   
		name = name.replace("'", "")                             
                values = dis.forecast(time_set, dis.rule)                
                dictUpdateParameters[name] = [dis, t, values[t]]
        # Initial conditions
	for initCond in IC_dict.itervalues():
	    if type(initCond) == SimpleInitialCondition:
	        name = initCond.name
		name = name.replace("'", "")
	        value = initCond.value	        
	        dictUpdateParameters[name] = [initCond, None, value]
	    else:
	        for indx in initCond._index:
		    if ',' in str(indx):		        	
	                name = initCond.name + '[' + \
	            		''.join(str(indx)[1:-1].split(' ')) + ']'
			name = name.replace("'", "")
	            else:
	            	name = initCond.name + '[' + str(indx) + ']'	
			name = name.replace("'", "")            
	            value = initCond[indx].value
	            dictUpdateParameters[name] = [initCond, indx, value]    
        # Manipulated variables
        if prediction_model:
            self.feedback_dict = {}	
            for manVar in manVar_dict.itervalues():
                for indx in manVar._index:
                    if ',' in str(indx):		        	
		        name = manVar.name + '[' + \
		    	    	    ''.join(str(indx)[1:-1].split(' ')) + ']'
	            else:
	                name = manVar.name + '[' + str(indx) + ']'	            
	            value = manVar[indx].value
	            self.feedback_dict[name] = value
	            dictUpdateParameters[name] = [manVar, indx, value]
	return dictUpdateParameters	        	      
	    	
    def update_dictUpdateParameters_OCP(self, current_time):
    	"""
    	It updates the dictionary that updates the parameters in the nl file
    	with the new values
    	"""    	        				    	
    	for item_name in self.dictUpdateParameters:
    	    item = self.dictUpdateParameters[item_name]    	    
    	    # Disturbances
    	    if type(item[0]) == Disturbance:   
    	    	if item[0].forecast_name == 'PERFECT':
    	    	    time_set = map(lambda x: x + current_time + self._sampling_time,
    								self._OCP_time)
    	    	    time_key = item[1] + current_time + self._sampling_time    
    	    	else:
    	    	    time_set = map(lambda x: x + current_time, self._OCP_time)
    	    	    time_key = item[1] + current_time 
                value = item[0].forecast(time_set, item[0].rule)[time_key]
            # Initial conditions    
            else:            	              	
            	item_PM = self.initial_conditions_PM[item[0].name]    
                if item[1] == None:
                    value = item_PM.variable[self._sampling_time].value	                    
            	elif type(item[1]) == tuple:            	    	
            	    var_indx = item[0].var_indx(item[1], self._sampling_time)
            	    value = item_PM.variable[var_indx].value
              	else:
              	    var_sets = item[0].variable._implicit_subsets	    	    
		    other_set = item[0]._index
		    other_set_position = var_sets.index(other_set)	      		      	
		    var_idx = [0]*2
		    var_idx[other_set_position] = item[1]
		    var_idx[1-other_set_position] = self._sampling_time
		    value = item_PM.variable[tuple(var_idx)].value	
	    self.dictUpdateParameters[item_name] = [item[0], item[1], value]	 
	 
    def update_dictUpdateParameters_PM(self, current_time, IC_values_dict, 
    	    						ManVar_values_dict):
    	"""
    	It updates the dictionary that updates the parameters in the nl file
    	with the new values for the prediction model
    	"""
    	#self.dictUpdateParameters_PM 	
    	time_set = map(lambda x: x + current_time, self._PM_time)    	
    	for item_name in self.dictUpdateParameters_PM:
    	    item = self.dictUpdateParameters_PM[item_name]    	    
    	    # Disturbances
    	    if type(item[0]) == Disturbance:    	
    	    	time_key = item[1] + current_time	    	
                value = item[0].forecast(time_set, item[0].rule)[time_key]
            # Manipulated varaible    
            elif type(item[0]) == ManipulatedVar:            	
                value = ManVar_values_dict[item_name]
            # Initial conditions    
            else:            	              	
            	value = IC_values_dict[item_name]
	    self.dictUpdateParameters_PM[item_name] = [item[0], item[1], value]	    	      
    
    def suffixes_declaration(self, model):
        """
        A function that declare all the suffixes neccesaries to access the nl
        file or for the asNMPC
        *It must be call after discretization
        """
        model.dual = Suffix(direction=Suffix.IMPORT)
	model.ipopt_zL_out = Suffix(direction=Suffix.IMPORT)
	model.ipopt_zU_out = Suffix(direction=Suffix.IMPORT)
	model.sens_state_0 = Suffix(direction=Suffix.EXPORT) 
	model.sens_state_1 = Suffix(direction=Suffix.EXPORT) 
	model.sens_state_value_1 = Suffix(direction=Suffix.EXPORT) 
	model.sens_init_constr = Suffix(direction=Suffix.EXPORT) 
	model.sens_sol_state_1 = Suffix(direction=Suffix.IMPORT) 
	model.sens_sol_state_1_z_L = Suffix(direction=Suffix.IMPORT)
	model.sens_sol_state_1_z_U = Suffix(direction=Suffix.IMPORT)    
	
    def suffixes_definition(self, model, time_set, 
    	    				dist_dict, IC_dict, manVar_dict, 
					prediction_model=False):
        """
        A function that defines all the suffixes for the artificial variables,
        artificial constraints, dual variables ...
        *It must be called after discretization
        """
        suffix_enum = 1
        #Disturbances
        for dis in dist_dict.itervalues():
            #Creation of artificial constraint for disturbances	
            art_cons_name = dis.name + '_artificial_constraint'
            dis_value = dis.forecast([t for t in time_set], dis.rule)
	    def _art_constraint(m, i):	    
	    	dis[i] = dis_value[i]		    	
	        return dis[i] == dis_value[i]
	    model.add_component(art_cons_name, Constraint(time_set,
	        rule = _art_constraint))	    
	    art_const = find_comp(art_cons_name, model)
            #Creation of suffixes for disturbances
            for indx in dis._index:
                model.sens_state_0[dis[indx]] = suffix_enum
		model.sens_state_1[dis[indx]] = suffix_enum
		model.sens_state_value_1[dis[indx]] = 0
		model.sens_init_constr[art_const[indx]] = suffix_enum
		suffix_enum += 1
        #Initial conditions
	for initCond in IC_dict.itervalues():
	    #Creation of artificial constraints for initial conditions
	    art_cons_name = initCond.name + '_artificial_constraint'
	    #Simple Initial condition	    
	    if type(initCond) == SimpleInitialCondition:	    	  
	    	initCond.__class__ = SimpleVar    			   	
	        def _art_constraint(m):	    		    	
	            return initCond == initCond.value
	        model.add_component(art_cons_name, 
	        		Constraint(rule = _art_constraint))       	        
	        #Creation of suffixes for initial conditions
	        art_const = find_comp(art_cons_name, model)
	        model.sens_state_0[initCond] = suffix_enum
		model.sens_state_1[initCond] = suffix_enum
		model.sens_state_value_1[initCond] = 0
		model.sens_init_constr[art_const] = suffix_enum
		suffix_enum += 1
	    #Indexed Initial condition
    	    else:	        
    	    	all_index = initCond._index   	           		    		
		def _art_constraint(m, *args):	   		    	
	            return initCond[args] == initCond[args].value
	        model.add_component(art_cons_name, Constraint(all_index, 
	        				rule = _art_constraint))	    	            
	        #Creation of suffixes for disturbances       
	        art_const = find_comp(art_cons_name, model)
	        for indx in all_index:	        	
		    model.sens_state_0[initCond[indx]] = suffix_enum
		    model.sens_state_1[initCond[indx]] = suffix_enum
		    model.sens_state_value_1[initCond[indx]] = 0
		    model.sens_init_constr[art_const[indx]] = suffix_enum
		    suffix_enum += 1	
        #Manipulated variables            
        if prediction_model:         		            	    
            for manVar in manVar_dict.itervalues():                    
                art_cons_name = manVar.name + '_artificial_constraint'
                all_index = manVar._index
                def _art_constraint(m, *args):	   		    	
	            return manVar[args] == manVar[args].value
	        model.add_component(art_cons_name, Constraint(all_index, 
	        					rule = _art_constraint))
	        #Creation of suffixes for manipulated variables
	        art_const = find_comp(art_cons_name, model)
	        for indx in all_index:	        	
	            model.sens_state_0[manVar[indx]] = suffix_enum
		    model.sens_state_1[manVar[indx]] = suffix_enum
		    model.sens_state_value_1[manVar[indx]] = 0
		    model.sens_init_constr[art_const[indx]] = suffix_enum
		    suffix_enum += 1	    		        

    def set_PieceWiseStepManipulatedVars(self):    
    	"""
    	This function uses the reduce_collocation_points method from the dae
    	module to transform the manipulated variables in piece wise step
    	functions
    	"""    	
    	if (type(self._discretize_method) == Collocation_Discretization_Transformation): 
    	    for ManVar in self.manipulated_var.itervalues():    	       	    
    	        self._discretize_method.reduce_collocation_points(self.OCP, 
    	        	var=ManVar, ncp=1, diffset=self._OCP_time)

    def set_ControlHorizonConstraints(self):
    	"""
    	This function adds the constraints of the control horizon over all the
    	manipulated variables. In other words, it set their value constant
    	after the control horizon length.
    	"""
        for ManVar in self.manipulated_var.itervalues():
            cons_name = ManVar.name + "_ControlHorizon_constraint"
            initial_time = min(self._OCP_time)
            final_time = max(self._OCP_time)    
            control_time = self._control_horizon*self._sampling_time           
            def _ControlHorizonConstraint(m, l):
                j_tmp = sorted(ManVar.keys())
                if (l == initial_time):
                    return ManVar[l] - ManVar[j_tmp[j_tmp.index(l)+1]] == 0
                elif (l >= control_time and 
                      Decimal(str(l))%Decimal(str(self._sampling_time)) == 0 and 
                      l < final_time):                   
                    return ManVar[l] - ManVar[j_tmp[j_tmp.index(l)+1]] == 0
                else:
                    return Constraint.Skip
            self.OCP.add_component(cons_name, Constraint(self._OCP_time,
            	    rule = _ControlHorizonConstraint))          
        
    def set_RealTime(self):
    	"""
    	This function sets the real time of the NMPC controller based on the 
    	sampling time and number of simulation periods
    	"""
    	self._real_time = [tmp_time + (period*self._sampling_time) \
    	    for period in range(self._simulation_periods) \
    	    for tmp_time in self._OCP_time if tmp_time <= self._sampling_time]
    	    
    def get_StVarSetNumber(self, time_set, a_StVar):
	"""
	This function returns the number of sets of a state variable and if
	the time set is included in it or not
	"""
	number_of_set = a_StVar.dim()	
	time_in_sets = False
	if (number_of_set == 1 and a_StVar._index == time_set):
	    time_in_sets = True
	elif (number_of_set >= 2 and 
		time_set in a_StVar._implicit_subsets):    
	    time_in_sets = True	       
        return number_of_set, time_in_sets
        
    def write_StVar(self, StVar, model_time, time_set, nl_map, Z, 
    	    		sensitivity = False, tau_CFI = 1):
        """
        This functions returns a tuple of two string where the first one are the
	names of the state variables and the second one the values of these 
	variables for the time specified        
        """
        var_titles = ''
        var_values = ''
        var_set_num, var_has_time = self.get_StVarSetNumber(time_set, StVar)
        if (var_set_num == 0):
            var_titles = var_titles + str(StVar) + ' '+ \
							str(StVar) + '_sens '
            var_values = var_values + str(StVar.value) + ' '
            old_value = StVar.value
            if sensitivity:
            	row_num = int(nl_map.pyomo2nl[str(StVar)][1:])
		new_value = float(Z[row_num])	
                var_values = var_values + str(tau_CFI*new_value + (1 - tau_CFI)*old_value) + ' '	
        elif (var_set_num == 1):
            if (var_has_time):
                var_titles = var_titles + str(StVar) + ' ' + \
                					str(StVar) + '_sens '
                var_values = var_values + str(StVar[model_time].value) + ' '
                old_value = StVar[model_time].value
                if sensitivity:					
                    row_num = int(nl_map.pyomo2nl[str(StVar) + '[' + str(model_time) + ']'][1:])
                    new_value = float(Z[row_num])	
                    var_values = var_values + str(tau_CFI*new_value + (1 - tau_CFI)*old_value) + ' '	
            else:
                for indx in StVar._index:
                    var_titles = var_titles + str(StVar) + \
                    	'[' + str(indx) + ']' + ' ' + str(StVar) + '_sens' + \
                    	'[' + str(indx) + ']' + ' '
                    var_values = var_values + str(StVar[indx].value) + ' '
                    old_value = StVar[indx].value
                    if sensitivity:	
                        row_num = int(nl_map.pyomo2nl[str(StVar) + '[' + str(indx) + ']'][1:])
                        new_value = float(Z[row_num])	
                    	var_values = var_values + str(tau_CFI*new_value + (1 - tau_CFI)*old_value) + ' '	 	              	
        elif (var_set_num >= 2):     
            if (var_has_time):
                time_index = StVar._implicit_subsets.index(time_set)		  	                                
                for indx in StVar._index:
                    indx_l = list(indx)
                    if (indx_l[time_index] == model_time): 
                    	indx_l[time_index] = 'Time'
                        var_titles = var_titles + str(StVar) + '[' + \
                            ', '.join(map(str, indx_l)).replace(' ', '') + \
                            ']' + ' ' + str(StVar) + '_sens' + '[' + \
                            ', '.join(map(str, indx_l)).replace(' ', '') + \
                            ']' + ' '	    
                    	indx_l[time_index] = model_time  
                    	var_values = var_values + \
                        	str(StVar[tuple(indx_l)].value) + ' '
                        old_value = StVar[tuple(indx_l)].value	
                    	if sensitivity:
                            row_num = int(nl_map.pyomo2nl[str(StVar) + '[' + \
                        ', '.join(map(str, indx)).replace(' ', '') + ']'][1:])
                            new_value = float(Z[row_num])	
                            var_values = var_values + str(tau_CFI*new_value + (1 - tau_CFI)*old_value) + ' '   
            else:
                for indx in StVar._index:
                    var_titles = var_titles + str(StVar) + '[' + \
                        ', '.join(map(str, indx)).replace(' ', '') + ']' + \
                        ' ' + str(StVar) + '_sens' + '[' + \
                        ', '.join(map(str, indx)).replace(' ', '') + ']' + ' '
                    var_values = var_values + str(StVar[indx].value) + ' '  
                    old_value = StVar[indx].value
                    if sensitivity:    
                        row_num = int(nl_map.pyomo2nl[str(StVar) + '[' + \
                        ', '.join(map(str, indx)).replace(' ', '') + ']'][1:])
                        new_value = float(Z[row_num])	
                        var_values = var_values + str(tau_CFI*new_value + (1 - tau_CFI)*old_value) + ' '     
        return var_titles, var_values                      
        
    def gjh_modification(self, gjh_input_file_name, gjh_output_file_name):
    	"""
    	It transfor the gjh original output file in a dat file compatible
    	with pyomo abstracs models
    	"""
        gjh_file = open(gjh_input_file_name, 'r')
        gjh_lines = gjh_file.readlines()   
        line0 = gjh_lines.index('param J :=\n')     
        if 'param H := ;\n' in gjh_lines:
            indx_H = gjh_lines.index('param H := ;\n')
            gjh_lines.pop(indx_H)
        gjh_file.close()
        gjh_new_lines = gjh_lines[line0:]
        gjh_data_file = open(gjh_output_file_name,'w')
        gjh_data_file.writelines(gjh_new_lines)
        gjh_data_file.close()    
            
    def load_gjh_results(self, nvar, ncons, data_file):    
    	"""
    	It creates a Pyomo model with the output of gjh in which the parameters
    	of the model correspond to the Gradient, the Jacobian and the Hessian
    	"""
        gjh = AbstractModel()
        gjh.n_var = Set(initialize=range(1, nvar + 1))
        gjh.n_cons = Set(initialize=range(1, ncons + 1))        
        gjh.J = Param(gjh.n_cons, gjh.n_var)
        gjh.H = Param(gjh.n_var, gjh.n_var)
        gjh_ins = gjh.create_instance(data_file)    
        return gjh_ins                    
              
    def gen_KKT(self, nl_map):
        """
        It takes the nl_file of an optimization problem and returns the inverse
        matrix of the KKT matrix
        """
        #Execute gjh               
        call(['gjh', nl_map.name + '.nl'])        
        #Modify gjh file          
        nvar = nl_map.var_num
        ncons = nl_map.cons_num        
        self.gjh_modification(nl_map.name + '.gjh', nl_map.name + '_gjh.dat')        
	#Pyomo model with results of gjh	
	gjh_ins = self.load_gjh_results(nvar, ncons, nl_map.name + '_gjh.dat')	   
        #KKT matrix construction  
        total_rows = nvar + ncons + nl_map.num_var_lo + nl_map.num_var_up
	KKT = lil_matrix((total_rows, total_rows))        
        for i, j in gjh_ins.J.keys():
            KKT[nvar+i-1, j-1] = gjh_ins.J[i, j]
            KKT[j-1, nvar+i-1] = gjh_ins.J[i, j]
        for i, j in gjh_ins.H.keys():
            KKT[i-1, j-1] = gjh_ins.H[i, j]                                        
        #Construct X and V matrix, #Construct Z, RHS vector                
        Z = lil_matrix((nvar+ncons+nl_map.num_var_lo+nl_map.num_var_up, 1))        
        cont_var_lo = 0
        cont_var_up = 0        
	for i in range(nvar+ncons):
	    if i < nvar:
		var = nl_map.var_dict['V'+str(i)]	
		var_name = nl_map.nl2pyomo['V'+str(i)] 
		var_obj = nl_map.pyomoName2pyomoObject[var_name]
		Z[i, 0] = var[0]
		if var[1] is not None:		    
		    KKT[nvar + ncons + cont_var_lo, nvar + ncons + cont_var_lo] = var[0] - var[1]
		    KKT[nvar + ncons + cont_var_lo, i] = self.OCP.ipopt_zL_out[var_obj]
		    KKT[i, nvar + ncons + cont_var_lo] = -1		    
		    Z[nvar + ncons + cont_var_lo, 0] = self.OCP.ipopt_zL_out[var_obj]
		    cont_var_lo += 1
		if var[2] is not None:		    
		    KKT[nvar + ncons + nl_map.num_var_lo + cont_var_up, nvar + ncons + nl_map.num_var_lo + cont_var_up] = var[2] - var[0]
		    KKT[nvar + ncons + nl_map.num_var_lo + cont_var_up, i] = self.OCP.ipopt_zU_out[var_obj]
		    KKT[i, nvar + ncons + nl_map.num_var_lo + cont_var_up] = 1		    		    
		    Z[nvar + ncons + nl_map.num_var_lo + cont_var_up, 0] = self.OCP.ipopt_zU_out[var_obj]
		    cont_var_up += 1
	    elif i >= nvar and i < nvar+ncons:
		Z[i, 0] = -nl_map.dual_dict['C'+str(i-nvar)]        							
	return Z, KKT            
	
    def gen_DP(self, current_time, real_IC_dict, nl_map):
    	"""
    	It returns the vector of the parameter difference
    	"""
    	DP = lil_matrix((nl_map.var_num + nl_map.cons_num + \
	    			nl_map.num_var_lo + nl_map.num_var_up, 1))	    
        for art_cons, art_var in nl_map.artcons2var.iteritems():
	    vector_pos = int(nl_map.pyomo2nl[art_cons][1:])	    
	    if art_var in real_IC_dict:
	        old_value = nl_map.pyomoName2pyomoObject[art_var].value 	
	        new_value = real_IC_dict[art_var]	            
	        DP[nl_map.var_num + vector_pos, 0] = new_value - old_value
	        #print art_var, old_value, new_value
	    else:
	        old_value = nl_map.pyomoName2pyomoObject[art_var].value	        
	        art_var_name = art_var.split('[')[0]	    
	        current_value = self.disturbances[art_var_name].get_realValue(current_time)
	        time_move = float(art_var.split('[')[1][:-1])
	        if self.disturbances[art_var_name].forecast_name == 'CONSTANT':	        		            
	            new_value = current_value
	        else:	        	
	            time_set = [current_time + time_move]	
	            new_value_list = self.disturbances[art_var_name].forecast(time_set, self.disturbances[art_var_name].rule)
	            new_value = new_value_list[time_set[0]]	            
	        DP[nl_map.var_num + vector_pos, 0] = new_value - old_value
		#print art_var, old_value, new_value       
        return DP
                    
    def clipping(self, nl_map, Z_sens):
        """
        A function that creates and solves a LP problem to find the value of
        tau for clipping into the fist interval
        """
        mCFI = ConcreteModel()
        mCFI.tau = Var(bounds = (0, 1))        
        # Constraints
        def _IneqCon(mCFI):
            for varobject in self.OCP.component_objects(Var, active = True):            
                for index in varobject:                                               		
                    if varobject[index].ub is not None:          
                        try:                                      
                            row_num = int(nl_map.pyomo2nl[cname(varobject[index])][1:])
                            sens_value = float(Z_sens[row_num])	 
			    current_value = value(varobject[index])
			    if current_value != sens_value:	
                                yield current_value*(1 - mCFI.tau) + \
                               		    mCFI.tau*sens_value <= varobject[index].ub            
                        except KeyError:
                            pass
                    if varobject[index].lb is not None:
                        try:                 
                            row_num = int(nl_map.pyomo2nl[cname(varobject[index])][1:])
                            sens_value = float(Z_sens[row_num])	
			    current_value = value(varobject[index])   
			    if current_value != sens_value:                         
                                yield current_value*(1 - mCFI.tau) + \
                            		    mCFI.tau*sens_value >= varobject[index].lb            
                        except KeyError:
                            pass	        	
        mCFI.IneqCon = ConstraintList(rule = _IneqCon)        
        # Objective
        mCFI.OBJ = Objective(expr = mCFI.tau, sense = maximize)
        # Solver      
        opt_tau = SolverFactory('glpk') # linear solver for this problem
        TauResults = opt_tau.solve(mCFI)
        # Return  
        return value(mCFI.tau)      
                    
    def solve(self, solver_name='ipopt', options=[], file_name='untitled', 
    	    real_plant = None, dynamic_plot=False, write_obj = False):
    	"""
    	This function solves the iNMPC over all the simulation periods stablished
    	"""    	
    	#Check the validity of the input data
    	for ManVar in self.manipulated_var.itervalues():
            ManVar.check_ManipulatedVar(self._OCP_time)
        for dist in self.disturbances.itervalues():
            dist.check_disturbance(self._OCP_time)
        for init_cond in self.initial_conditions.itervalues():
            init_cond.check_InitialCondition(self._OCP_time)
        if real_plant == None:
            raise TypeError("No function has been assigned to generate the "\
            	    "real values of the process states")
    	#It is neccesary to add the reamining components to the model    
        self.set_PieceWiseStepManipulatedVars()
        self.set_ControlHorizonConstraints()
        #Declare suffixes
        self.suffixes_declaration(self.OCP)        
        self.suffixes_declaration(self.PM)          
        #Define suffixes
        self.suffixes_definition(self.OCP, self._OCP_time, 
        		self.disturbances, self.initial_conditions, 
        		self.manipulated_var, prediction_model=False)	        
        self.suffixes_definition(self.PM, self._PM_time, 
        		self.disturbances_PM, self.initial_conditions_PM, 
        		self.manipulated_var_PM, prediction_model=True)
        #Create the nl file
        PM_nl_map = nl_map_asNMPC(self.PM, file_name = file_name + '_PM')
        OCP_nl_map = nl_map_asNMPC(self.OCP, file_name = file_name)
        sol_Reader = ResultsReader_sol()        
        #Solver options
        opt_str = 'print_level 0 wantsol 1'
        for op in options:
            opt_str += ' ' + str(op[0]) + ' ' + str(op[1])  	                       
        #Open file to save results    	    	
	profile_results_list = []
	profile_results = open(file_name+'_asNMPC_profiles_results.txt', 'w')	
    	computational_results = open(file_name + '_asNMPC_computational_results.txt', 'w')
    	#Write titles in real values and first values
	ans = 'Time '
	real_IC_dict = {}
	for init_cond in self.initial_conditions.itervalues():
	    ans = ans + self.write_StVar(init_cond, min(self._OCP_time), self._OCP_time, None, [])[0]   
	    IC_titles = self.write_StVar(init_cond, min(self._OCP_time), self._OCP_time, None, [])[0][:-1].split(' ')
	    IC_values = self.write_StVar(init_cond, min(self._OCP_time), self._OCP_time, None, [])[1][:-1].split(' ')	    
	    for indx in range(len(IC_values)):	 	    	 
	        real_IC_dict[IC_titles[indx*2]] = float(IC_values[indx])	       
    	#Write titles in profile file
    	ans = 'Time '
    	for dis in self.disturbances.itervalues():
            ans = ans + str(dis) + ' '
        for ManVar in self.manipulated_var.itervalues():
            ans = ans + str(ManVar) + ' ' + str(ManVar) + '_sens '
        for StVar in self.state_var.itervalues():              
            ans = ans + self.write_StVar(StVar, min(self._OCP_time), self._OCP_time, None, [])[0]            
	ans = ans + '\n'
	number_disturbances = len(self.disturbances)
	number_ManipulatedVar = len(self.manipulated_var)	
	number_StateVar = int((len(ans.split(' ')) - len(self.disturbances) \
		         - 2*len(self.manipulated_var) - 2)/2) 	
	profile_results_list.append(ans)	
	profile_results.write(ans)	   
	#Write titles in computational results
	computational_results_1 = 'Periods TerminationCondition' +\
    		' SimulationTime_Prediction[secs] SimulationTime_OCP[secs]' +\
    		' KKT_calculation[secs] SimulationTime_Sensitivity[secs]' +\
    		' tau_CFI ObjectiveFunction '
    	if write_obj:
    	    for i_obj in self.OCP.obj_set:
    	        computational_results_1 = computational_results_1 + \
    	        			  cname(self.OCP.obj_exp[i_obj]) + ' ' 	    
    	computational_results.write(computational_results_1 + '\n')        	
    	#Create plots
    	if (dynamic_plot):    	                   
            ydata_plot = {}
            dynamic_plots = {}            
            plot_names = ['Disturbances', 'Manipulated Variables',
                'State Variables']
            plot_legends = {'Disturbances':\
            	    ans.split(' ')[1:number_disturbances+1],
            	    'Manipulated Variables':\
            	    ans.split(' ')[number_disturbances+1:number_disturbances+\
            	    			2*number_ManipulatedVar+1],
            	    'State Variables':\
            	    ans.split(' ')[number_disturbances+2*number_ManipulatedVar+1:\
            			   number_disturbances+2*number_ManipulatedVar+\
            			   2*number_StateVar+1] }
	    plot_total_variables = {'Disturbances':number_disturbances,
            	    'Manipulated Variables':2*number_ManipulatedVar,
            	    'State Variables':2*number_StateVar }                   
            for i in plot_names:
                dynamic_plots[i] = DynamicPlot(i, 'Time', '', 
                	plot_legends[i] , plot_total_variables[i]) 
        #Definitions for reading the sol file
	sens_var_num = None
	sens_sol_state_1_line = None   
	sensitivity_time = None
        #Solution
        for period in range(self._simulation_periods + 1):
            #Current time	
            current_time = period*self._sampling_time       
            tau_CFI = 1
	    #Update initial guess
	    if period == 0:	    	
	        OCP_nl_map.update_InitialGuess(self.OCP, update_duals=False)
	        PM_nl_map.update_InitialGuess(self.PM, update_duals=False)
            #Run sensitivity
            if period > 0:
                #Compute sensitivity step
                initial_time = time.time()	
	        DP = self.gen_DP(current_time, real_IC_dict, OCP_nl_map)	    
	        DZ = spsolve(csr_matrix(KKT), csr_matrix(DP))	        
	        Z_sens = Z + np.matrix(DZ).T	        
	        final_time = time.time() 
	        sensitivity_time = final_time - initial_time
		#Update feedback_dict	
		tau_CFI = self.clipping(OCP_nl_map, Z_sens)		
		for manVar in self.feedback_dict.keys():		    
		    row_num = int(OCP_nl_map.pyomo2nl[manVar][1:])
		    new_value = float(Z_sens[row_num])			    
	    	    old_value = float(Z[row_num, 0])
		    self.feedback_dict[manVar] = tau_CFI*new_value + (1 - tau_CFI)*old_value
	        #Write results		        
                ans = str(current_time) + ' '
                for dis in self.disturbances.itervalues():
                    ans = ans + str(dis.get_realValue(current_time)) + ' '                     
                for ManVar in self.manipulated_var.itervalues():                    
                    ans = ans + self.write_StVar(ManVar, 0, self._OCP_time, 
                    	    		OCP_nl_map, Z_sens, sensitivity = True, 
                    	    		tau_CFI = tau_CFI)[1]   
                for StVar in self.state_var.itervalues():
                    ans = ans + self.write_StVar(StVar, 0, self._OCP_time, 
                    	    		OCP_nl_map, Z_sens, 
                    	    		sensitivity = True)[1]      		                             
            	ans = ans + '\n'     
            	profile_results_list.append(ans)
            	profile_results.write(ans)                	 
	        #Update PM          
                self.update_dictUpdateParameters_PM(current_time, real_IC_dict, self.feedback_dict)   
                PM_nl_map.update_Parameters(self.dictUpdateParameters_PM)	   
            #Solution of prediction model
            initial_time = time.time()	
	    call([solver_name, file_name + '_PM.nl', opt_str])	                                  
            #Read solution - PM            
            PM_results = sol_Reader(file_name+'_PM.sol', None, None, 
            	    suffixes=['dual', 'ipopt_zU_out', 'ipopt_zL_out', 
            	    	'ipopt_zU_in', 'ipopt_zL_in', 'sens_state_0', 
            	    	'sens_state_1', 'sens_state_value_1'])            	
            PM_results._smap = PM_nl_map.symbol_map		
            self.PM.solutions.load_from(PM_results,
            	    				delete_symbol_map=False)
            PM_nl_map.update_InitialGuess(self.PM, update_duals=True)   
            #Write results for first period
            if period == 0:                        
                ans = str(current_time) + ' '
                for dis in self.disturbances.itervalues():
                    ans = ans + str(dis.get_realValue(current_time)) + ' '                     
                for ManVar in self.manipulated_var_PM.itervalues():                    
                    ans = ans + self.write_StVar(ManVar, 0, self._PM_time, PM_nl_map, [0]*PM_nl_map.var_num, sensitivity = True)[1]		    
                for StVar in self.state_var_PM.itervalues():
                    ans = ans + self.write_StVar(StVar, 0, self._PM_time, PM_nl_map, [0]*PM_nl_map.var_num, sensitivity = True)[1]   		                             
            	ans = ans + '\n'                 
            	#profile_results_list.append(ans)
            	profile_results.write(ans)       
            #Update initial conditions and disturbances of OCP
            self.update_dictUpdateParameters_OCP(current_time)
            OCP_nl_map.update_Parameters(self.dictUpdateParameters)
            final_time = time.time() 
            solution_time_PM = final_time - initial_time
            #Solution of OCP
	    initial_time = time.time()	
	    call([solver_name, file_name + '.nl',opt_str])	                                  
            #Read solution - OCP            
            NMPC_results = sol_Reader(file_name+'.sol', None, None, 
            	    suffixes=['dual', 'ipopt_zU_out', 'ipopt_zL_out', 
            	    	'ipopt_zU_in', 'ipopt_zL_in', 'sens_state_0', 
            	    	'sens_state_1', 'sens_state_value_1'])            	
            NMPC_results._smap = OCP_nl_map.symbol_map		
            self.OCP.solutions.load_from(NMPC_results,
            	    				delete_symbol_map=False)
            OCP_nl_map.update_InitialGuess(self.OCP, update_duals=True)  
            final_time = time.time()  
            solution_time_OCP = final_time - initial_time
            #Calculate KKT^-1 matrix for sensitivity     
            initial_time = time.time()	
            Z, KKT = self.gen_KKT(OCP_nl_map)   
            final_time = time.time()  
            KKT_time = final_time - initial_time
            #Read next state
            real_IC_dict = real_plant(self.manipulated_var_PM, 
                			self.initial_conditions_PM, current_time)            
            #Display report
            print '------------------------------------------------------------'
            print 'Simulation period: ' + str(period+1)
            print 'Termination condition: ' +\
                str(NMPC_results.solver.termination_condition)
            print 'Prediction model solution time: ' + str(solution_time_PM) + ' secs'
            print 'OCP solution time: ' + str(solution_time_OCP) + ' secs'            
            print 'KKT calculation time: ' + str(KKT_time) + ' secs'
            print 'Sensitivity calculation time: ' + str(sensitivity_time) + ' secs'
            print 'Objective function value: ' + str(value(self.OCP.NEW_OBJ))            
            print '------------------------------------------------------------'
            #Write computational results    
            cpu_results = str(period+1) + ' ' +\
            	    	  str(NMPC_results.solver.termination_condition) +\
            	    	  ' ' + str(solution_time_PM) +\
            	    	  ' ' + str(solution_time_OCP) +\
            	    	  ' ' + str(KKT_time) +\
            	    	  ' ' + str(sensitivity_time) +\
            	    	  ' ' + str(tau_CFI) +\
            	    	  ' ' + str(value(self.OCP.NEW_OBJ)) + ' '            
            #Write objectives
            if write_obj:
                for i_obj in self.OCP.obj_set:
                    cpu_results = cpu_results + \
                    		  str(value(self.OCP.obj_exp[i_obj])) + ' ' 
            #Write to file
            computational_results.write(cpu_results + '\n')     	    
            #Dynamic plot            
            if (dynamic_plot and period > 0):   
            	#Reults matrix                	
            	results = [map(float,rr.split(' ')[:-1]) \
            		   for rr in profile_results_list \
            		   if profile_results_list.index(rr)>0]            		   
            	results_transpose = [[row[i] for row in results] \
            				for i in range(len(results[0]))]            		
		# Plots
		t_plot = results_transpose[0]
		ydata_plot['Disturbances'] = results_transpose[1:\
						number_disturbances+1]
		ydata_plot['Manipulated Variables'] = \
			results_transpose[number_disturbances+1:\
				number_disturbances+1+2*number_ManipulatedVar]
		ydata_plot['State Variables'] = \
			results_transpose[number_disturbances+1+\
				2*number_ManipulatedVar:\
				number_disturbances+1+2*number_ManipulatedVar+\
				2*number_StateVar]		
		for i in plot_names:
		    dynamic_plots[i].update_plot(t_plot, ydata_plot[i]) 			    		    
        #Write and close files        
        computational_results.close()
        profile_results.close()        
        #Hold plots at the end
        if dynamic_plot:
            for i in plot_names:
                    dynamic_plots[i].display_final_plot()                               
